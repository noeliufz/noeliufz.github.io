<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Arch Linux安装（自用）</title>
    <link href="/2024/12/16/an-zhuang-arch-linux/"/>
    <url>/2024/12/16/an-zhuang-arch-linux/</url>
    
    <content type="html"><![CDATA[<h1 id="archlinux安装方法">ArchLinux安装方法</h1><p>制作镜像略</p><h1 id="进入系统后">进入系统后</h1><h2 id="连接网络">连接网络</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sh">iwctl<br>device list<br>station wlan0 scan<br>station wlan0 get-networks<br>station wlan0 connect &lt;name&gt;<br></code></pre></td></tr></table></figure><h2 id="换源">换源</h2><p><code>reflector --country China --latest 10 --sort rate --save /etc/pacman.d/mirrorlist</code></p><p>后续脚本中不再换源</p><h2 id="使用archinstall脚本">使用<code>archinstall</code>脚本</h2><p>注意挂载<code>efi</code>为<code>/boot</code></p><h2 id="出现意外修复grub">（出现意外）修复grub</h2><p>挂载<code>/</code>到<code>/mnt</code>挂载<code>efi</code>为<code>/boot</code></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs sh">mount -t proc /proc /mnt/proc<br>mount --rbind /sys /mnt/sys<br>mount --rbind /dev /mnt/dev<br>mount --rbind /run /mnt/run<br><span class="hljs-comment"># 进入新系统</span><br>arch-chroot /mnt<br>grub-install --target=x86_64-efi --efi-directory=/boot --bootloader-id=GRUB<br>grub-mkconfig -o /boot/grub/grub.cfg<br>efibootmgr --create --disk /dev/nvme0n1p1 --part 1 --label <span class="hljs-string">&quot;Arch&quot;</span> --loader /EFI/GRUB/grubx64.efi<br><span class="hljs-comment"># 最后一句中实际文件是在/boot/EFI/GRUB/grubx64.efi中，但不要加/boot</span><br></code></pre></td></tr></table></figure><h1 id="安装hyprland">安装Hyprland</h1><p>使用已有配置库Hyprdots安装</p><h1 id="关闭内置显示器">关闭内置显示器</h1><p><code>hyprctl keyword monitor "eDP-1,disable"</code><code>hyprctl keyword monitor "HDMI-A-1,1920x1080@75,0x0,1.0”</code></p><h1 id="防止合盖睡眠">防止合盖睡眠</h1><p>修改<code>/etc/systemd/login.conf</code>中<code>HandleLidSwitch</code>系列值为<code>ignore</code></p><h1id="修复hyprland下微信无法使用fcitx5">修复Hyprland下微信无法使用fcitx5</h1><p>arch Linux AUR中已有官方微信<code>wechat-bin</code></p><p>在<code>/etc/environment</code>中添加<code>QT_IM_MODULE=fcitx</code></p>]]></content>
    
    
    
    <tags>
      
      <tag>Arch</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>虚函数</title>
    <link href="/2024/08/21/xu-han-shu/"/>
    <url>/2024/08/21/xu-han-shu/</url>
    
    <content type="html"><![CDATA[<p>C++中虚函数的作用是实现动态多态，能够使用指向派生类的基类指针调用派生类的重写的函数。如果不使用虚函数可能会有一些奇妙的现象。</p><h1 id="如果不使用虚函数会发生什么呢">如果不使用虚函数会发生什么呢</h1><p>有以下代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span><br>&#123;<br>  <span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> value = <span class="hljs-number">10</span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printValue</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;A::value = &quot;</span> &lt;&lt; value &lt;&lt; std::endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> : <span class="hljs-keyword">public</span> A<br>&#123;<br>  <span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> value = <span class="hljs-number">20</span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printValue</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;B::value = &quot;</span> &lt;&lt; value &lt;&lt; std::endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    B b = <span class="hljs-built_in">B</span>();<br>    b.<span class="hljs-built_in">printValue</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果为 <code>B::value = 20</code></p><p>结果是正确的，实例<code>b</code>调用的是B类重写的函数，显示的为B类的<code>value</code>值。</p><p>但如果<code>main</code>函数中使用的为指针，见下情况：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    A *p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">B</span>();<br>    p-&gt;<span class="hljs-built_in">printValue</span>();<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Accessed value: &quot;</span> &lt;&lt; p-&gt;value &lt;&lt; std::endl;<br>    <span class="hljs-keyword">delete</span> p;<br>    p = <span class="hljs-literal">nullptr</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出的结果为 <code>A::value = 10 Accessed value: 10</code></p><p>可发现指针调用的还是类A的函数，访问的也为类A的变量。这是因为，指针<code>p</code>为类A类型的指针，在编译阶段就已确定其类型，实现的为静态绑定，要调用的函数在编译时就已确定。</p><p>见<code>p-&gt;printValue()</code>对应的汇编代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs assembly">movq    -24(%rbp), %rax<br>movq    %rax, %rdi<br>call    A::printValue()<br></code></pre></td></tr></table></figure><h1 id="如何解决">如何解决</h1><p>为解决此问题，可将类A中函数定义为虚函数，加上关键词<code>virtual</code>。这样在编译阶段会为类生成一个虚函数表，函数表中的指针指向的为函数的地址。这样在派生类中重写时，会在派生类的虚函数表中更新，这样在使用指针调用时，会去虚函数表中查询函数的地址，就会调用自己的（重写的）函数。此时该调用哪个函数是运行时确定的，实现的是动态绑定。</p><p>见代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span><br>&#123;<br>  <span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> value = <span class="hljs-number">10</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">printValue</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;A::value = &quot;</span> &lt;&lt; value &lt;&lt; std::endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> : <span class="hljs-keyword">public</span> A<br>&#123;<br>  <span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> value = <span class="hljs-number">20</span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printValue</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;B::value = &quot;</span> &lt;&lt; value &lt;&lt; std::endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    A *p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">B</span>();<br>    p-&gt;<span class="hljs-built_in">printValue</span>();<br>    <span class="hljs-keyword">delete</span> p;<br>    p = <span class="hljs-literal">nullptr</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果 <code>B::value = 20</code></p><p>见<code>p-&gt;printValue()</code>汇编代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs x86_64">movq    -24(%rbp), %rax     ; this指针指向当前对象实例<br>movq    (%rax), %rax        ; 从 %rax 寄存器中保存的地址（即当前对象的起始位置）加载一个值到 %rax。<br>                            ; 这个值通常是对象的虚函数表指针（vtable pointer），因此现在 %rax 中存储的是虚函数表的地址。<br>movq    (%rax), %rdx        ; 从 %rax 指向的虚函数表地址中读取第一个64位的值，并存储到 %rdx。这个值是虚函数表中第一个函数的地址。<br>movq    -24(%rbp), %rax     ; 再次从栈帧的 -24 位置加载 this 指针到 %rax，准备作为参数传递给即将调用的函数。<br>movq    %rax, %rdi          ; 将 this 指针存储到 %rdi 寄存器中。<br>call    *%rdx               ; 调用虚函数表的第一个函数.此时，%rdi 已经包含了 this 指针，函数调用时将把 this 指针传递给被调用的虚函数。<br></code></pre></td></tr></table></figure><h1 id="其他发现">其他发现</h1><p>同时可见汇编代码中增加了虚函数表和类型信息。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs x86_64">vtable for B:<br>        .quad   0<br>        .quad   typeinfo for B<br>        .quad   B::printValue()<br>vtable for A:<br>        .quad   0<br>        .quad   typeinfo for A<br>        .quad   A::printValue()<br>typeinfo for B:<br>        .quad   vtable for __cxxabiv1::__si_class_type_info+16<br>        .quad   typeinfo name for B<br>        .quad   typeinfo for A<br>typeinfo name for B:<br>        .string &quot;1B&quot;<br>typeinfo for A:<br>        .quad   vtable for __cxxabiv1::__class_type_info+16<br>        .quad   typeinfo name for A<br>typeinfo name for A:<br>        .string &quot;1A&quot;<br></code></pre></td></tr></table></figure><h2 id="vtable-for-b"><code>vtable for B</code></h2><p>第一项为指示虚基类指针的位置。如果没有虚基类，这个条目是空的（即0）。</p><p>第二项为指向B类的类型信息结构的指针（即RTTI信息）。</p><p>第三项开始是指向类B的虚函数。这里为<code>printValue()</code>的指针。当通过B类的对象调用这个虚函数时，会跳转到这个地址。</p><h2 id="typeinfo-for-b"><code>typeinfo for B</code></h2><p>此为类的类型信息。</p><p>第一项为指向<code>__si_class_type_info</code>类的虚函数表（用来表示单继承类型信息），是编译器生成的内部结构。</p><p>第二项为指向表示 B类名称的字符串。（可用<code>typeid</code>函数查看到）。</p><p>第三项为指向基类 A 的类型信息。这表明 B 是从 A 继承而来。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>最小的程序</title>
    <link href="/2024/08/19/zui-xiao-de-cheng-xu/"/>
    <url>/2024/08/19/zui-xiao-de-cheng-xu/</url>
    
    <content type="html"><![CDATA[<p>最近在读《程序员的自我修养——链接、装载与库》收获匪浅。在4.6节中介绍链接过程时，书中有一个最“小”的程序的例子故想尝试。但发现书中例子是32位系统的例子，对于64位系统的情况有些许不同，故尝试改写为64位版。</p><h1 id="位版本">32位版本</h1><p>原书代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">char</span> *str = <span class="hljs-string">&quot;Hello world!\n&quot;</span>;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">print</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-keyword">asm</span>( <span class="hljs-string">&quot;movl $13,%%edx \n\t&quot;</span><br>        <span class="hljs-string">&quot;movl %0,%%ecx  \n\t&quot;</span><br>        <span class="hljs-string">&quot;movl $1,%%ebx  \n\t&quot;</span>   <span class="hljs-comment">// 原书为$0，对应stdin；实际应为$1，对应标准输出stdout。</span><br>        <span class="hljs-string">&quot;movl $4,%%eax  \n\t&quot;</span><br>        <span class="hljs-string">&quot;int $0x80      \n\t&quot;</span><br>        ::<span class="hljs-string">&quot;r&quot;</span>(str):<span class="hljs-string">&quot;edx&quot;</span>,<span class="hljs-string">&quot;ecx&quot;</span>,<span class="hljs-string">&#x27;&quot;ebx&quot;);</span><br><span class="hljs-string">&#125;</span><br><span class="hljs-string"></span><br><span class="hljs-string">void exit()</span><br><span class="hljs-string">&#123;</span><br><span class="hljs-string">    asm( &quot;movl $42,%ebx  \n\t&quot;</span><br><span class="hljs-string">        &quot;movl $1, %eax  \n\t&quot;</span><br><span class="hljs-string">        &quot;int $0x80      \n\t&quot; );</span><br><span class="hljs-string">&#125;</span><br><span class="hljs-string"></span><br><span class="hljs-string">void nomain()</span><br><span class="hljs-string">&#123;</span><br><span class="hljs-string">    print();</span><br><span class="hljs-string">    exit();</span><br><span class="hljs-string">&#125;</span><br></code></pre></td></tr></table></figure><h2 id="代码注解">代码注解</h2><p>代码使用了内嵌汇编代码。<code>nomain</code>我们在链接阶段可指定为程序的入口。其中调用了两个函数：<code>print</code>和<code>exit</code>。</p><p>在<code>print</code>中实现了系统调用。通过调用0x80中断，<code>eax</code>为调用号，<code>ebx</code>,<code>ecx</code>,<code>edx</code>等通用寄存器来传递参数。在些函数中调用号（<code>eax</code>的值）为4，对应为<code>write</code>，原型为：</p><p><code>int write(int filedesc, char* buffer, int size)</code></p><p>在代码中<code>ebx</code>,<code>ecx</code>,<code>edx</code>分别对应了这三项参数。</p><p><code>movl $13,%%edx</code>中将<code>edx</code>设置为13，对应文本size为13；</p><p><code>movl %0,%%ecx</code>的占用符与后面<code>"r"(str)</code>结合，将文本地址写入<code>ecx</code>；</p><p><code>movl $1,%%ebx</code>将文件描述符写入<code>ebx</code>。此处原书有误使用了<code>$0</code>，在Linux中文件描述符0对应为标准输入（stdin），实际应该1对应为标准输出（stdout）。</p><p><code>movl $4,%%eax</code>将调用号4写入<code>eax</code>，对应调用的是<code>write</code>函数。</p><p><code>int $0x80</code>调用中断，系统会去查找中断向量表，<code>0x80</code>对应的为中断服务程序（system_call），该程序查询系统调用表找到调用号（<code>eax</code>的值为4的函数对应为<code>write</code>对其进行调用，实现向标准输出写入字符串。</p><p>过程可见下图（例子并非<code>write</code>而是<code>fork</code>但原理类似），图片为书中第12章内容。</p><figure><img src="/img/tinyobject/interrupt.png" alt="系统调用过程" /><figcaption aria-hidden="true">系统调用过程</figcaption></figure><p>在<code>exit</code>函数中则比<code>print</code>简单一些，将系统调用的<code>EXIT</code>的调用号1存入<code>eax</code>，将<code>EXIT</code>的参数，退出码，42存入<code>ebx</code>之后调用中断实现对<code>EXIT</code>系统调用的调用。</p><p>另外书中也介绍到，使用<code>echo $?</code>命令可查看上一条bash命令执行的程序的退出码。另外自己调用<code>EXIT</code>系统调用而不是<code>return 0</code>是因为，普通程序的<code>main()</code>结束后会将控制权返回给系统库，由系统库负责调用<code>EXIT</code>退出进程。而这里的<code>nomain()</code>结束后系统控制权不会返回，可能执行到<code>nomain()</code>后面不正常的指令，最终导致进程异常退出。</p><h2 id="编译链接">编译、链接</h2><p>使用命令</p><p><code>gcc -c -fno-builtin TinyHelloWorld.c</code><code>ld -static -e nomain -o TinyHelloWorld TinyHelloWorld.o</code></p><p>进行编译链接。</p><p><code>-fno-builtin</code>的作用是禁用GCC编译器的内置函数。GCC会将一些常用的C库函数替换成编译器的内置函数，以达优化目的。如GCC会次只有字符串参数的<code>printf</code>替换成<code>puts</code>，节省格式解析的时间。<code>exit()</code>也是内置函数之一，故在些要将内置函数关闭。</p><p><code>-e nomain</code>表示该程序的入口函数为<code>nomain</code>。</p><h1 id="位版本-1">64位版本</h1><p>代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">char</span>* str = <span class="hljs-string">&quot;Hello world!\n&quot;</span>;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">print</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-keyword">asm</span>(<span class="hljs-string">&quot;movq $13, %%rdx \n\t&quot;</span>   <br>        <span class="hljs-string">&quot;movq %0, %%rsi  \n\t&quot;</span>   <br>        <span class="hljs-string">&quot;movq $1, %%rdi  \n\t&quot;</span>   <br>        <span class="hljs-string">&quot;movq $1, %%rax  \n\t&quot;</span>   <span class="hljs-comment">// 系统调用号 (sys_write)</span><br>        <span class="hljs-string">&quot;syscall \n\t&quot;</span>           <span class="hljs-comment">// 使用syscall指令</span><br>        ::<span class="hljs-string">&quot;r&quot;</span>(str):<span class="hljs-string">&quot;rdx&quot;</span>,<span class="hljs-string">&quot;rsi&quot;</span>,<span class="hljs-string">&quot;rdi&quot;</span>);<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">exit</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-keyword">asm</span>(<span class="hljs-string">&quot;movq $42, %rdi \n\t&quot;</span>   <br>        <span class="hljs-string">&quot;movq $60, %rax \n\t&quot;</span>   <span class="hljs-comment">// 系统调用号 (sys_exit)</span><br>        <span class="hljs-string">&quot;syscall \n\t&quot;</span>);<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">nomain</span><span class="hljs-params">()</span><br>&#123;<br>    print();<br>    <span class="hljs-built_in">exit</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>64位系统与32位系统有些许不同。</p><p>首先是系统调用号，<code>write</code>与<code>exit</code>在64位Linux下对应的为1与60，而非32位系统下的4与1。另外在调用系统调用时会使用<code>syscall</code>指令。</p><h1 id="其他发现">其他发现</h1><p>使用<code>objdump -s</code>可看到，段<code>.text</code>为程序的指令；<code>.rodata</code>为字符串"Helloworld!"；<code>.data</code>保存的是str的全局变量的地址，也就是0x402000；<code>.eh_frame</code>是编译器生成的与C++异常处理相关的内容；<code>.comment</code>就是编译器版本信息。</p><figure><img src="/img/tinyobject/section.png" alt="反汇编段信息" /><figcaption aria-hidden="true">反汇编段信息</figcaption></figure><p>使用<code>objdump -S</code>可看到汇编代码与我们写的一样。</p><figure><img src="/img/tinyobject/S.png" alt="反汇编" /><figcaption aria-hidden="true">反汇编</figcaption></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Nes模拟器6502CPU的Debug</title>
    <link href="/2024/06/29/nes-mo-ni-qi-6502cpu-de-debug/"/>
    <url>/2024/06/29/nes-mo-ni-qi-6502cpu-de-debug/</url>
    
    <content type="html"><![CDATA[<p>最近在跟着<ahref="https://bugzmanov.github.io/nes_ebook/chapter_1.html">NESebook</a>写NES模拟器。项目是用Rust写的，但是我想锻炼一下自己的C++能力就按照思路自己用C++写。</p><p>昨日写完6502 CPU的部分，用p6502汇编的代码的<ahref="https://gist.github.com/wkjagt/9043907">贪吃蛇 bywkjagt</a>进行测试，但会有奇怪的bug。</p><p>bug表现为按下按键后，如果方向改为上或下，蛇的位置会固定刷新在一个奇怪的位置，增长速度也会快，会正常撞墙结束游戏，但是恢复在左右方向就会正常。如图是按下方向上后的蛇的位置（白点处）。</p><figure><img src="/img/nes/bug.png" alt="bug" /><figcaption aria-hidden="true">bug</figcaption></figure><p>另外，奖励的苹果的位置大多时间显示不出来，运行了几十次会有一两次能正常显示且颜色正常变化。</p><p>想着这快2000行代码那么多条指令也不知道到底出现问题在哪里，为了避免盲目检查，先分析一下问题。</p><p>看了原始的汇编代码的游戏逻辑和内存分布。</p><p><code>$00-01</code>为存储苹果位置的地址，打印发现内容正常。</p><p><code>$10-11</code>为存储蛇头位置的地址，发现在按下方向键后会重置为0，可疑。</p><p><code>$02</code>为目前方向，发现在按下按键后能正常变化。</p><p><code>$03</code>为蛇长，一切正常。</p><p>游戏主逻辑为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs ASSEMBLY">loop:<br>  ;the main game loop<br>  jsr readKeys         ;jump to subroutine readKeys<br>  jsr checkCollision   ;jump to subroutine checkCollision<br>  jsr updateSnake      ;jump to subroutine updateSnake<br>  jsr drawApple        ;jump to subroutine drawApple<br>  jsr drawSnake        ;jump to subroutine drawSnake<br>  jsr spinWheels       ;jump to subroutine spinWheels<br>  jmp loop             ;jump to loop (this is what makes it loop)<br></code></pre></td></tr></table></figure><p>根据上面的分析可知<code>readKeys</code>正常。结合游戏表现，撞墙能正常结束游戏，<code>checkCollision</code>应该也是正常的。在改变方向前，蛇的增长也是正常的，<code>updateSnake</code>不确定是否有问题。苹果大多时间不能显示但也有能显示出的时候，且能显示的时候表现是正常的，<code>drawApple</code>可能会有问题但应该不是主要问题。蛇显示都是正常的，只是位置更新有问题<code>drawSnake</code>应该是没有问题的。</p><p>分析后思路更清晰了，感觉应该是在<code>updateSnake</code>中改变方向后的问题，结合之前发现<code>$10</code>存储蛇头位置的地址数值会在方向改变之后清零，去看了下操作<code>$10</code>地址值的代码有哪些。</p><p>在<code>updateSnake</code>中会进入<code>updateloop</code>循环，其中会根据方向进入不同分支。观察分支代码，只有上下方向会调用<code>sta $10</code>对地址<code>$10</code>进行操作（将<code>a</code>寄存器的值存入地址<code>$10</code>），与我这个bug只会在上下方向出问题一样。</p><p>检查代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs ASSEMBLY">up:<br>  lda $10   ;put value stored at address $10 (the least significant byte, meaning the<br>            ;position in a 8x32 strip) in register A<br>  sec       ;set carry flag<br>  sbc #$20  ;Subtract with Carry: subtract hex $20 (dec 32) together with the NOT of the<br>            ;carry bit from value in register A. If overflow occurs the carry bit is clear.<br>            ;This moves the snake up one row in its strip and checks for overflow<br>  sta $10   ;store value of register A at address $10 (the least significant byte<br>            ;of the head&#x27;s position)<br>  bcc upup  ;If the carry flag is clear, we had an overflow because of the subtraction,<br>            ;so we need to move to the strip above the current one<br>  rts       ;return<br></code></pre></td></tr></table></figure><p>发现在<code>sta</code>之前会先执行<code>sbc</code>操作（SubstractwithBorrow，带借位减法）对寄存器<code>a</code>进行更新，检查一下自己<code>sbc</code>操作的代码果然有问题！问题在于每次计算完成后调用了一个helperfunction还会再对carrybit进行一次计算导致寄存器<code>a</code>的值异常。改好后就能成功运行啦！蛇的运行也正常了，苹果也都能显示出来了，玩了一会一切正常！</p><p>改后长这样</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">CPU::SBC</span><span class="hljs-params">(<span class="hljs-type">const</span> AddressingMode &amp;mode)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// A - M - C̅ -&gt; A</span><br>    <span class="hljs-type">uint16_t</span> addr = <span class="hljs-built_in">get_operand_address</span>(mode);<br>    <span class="hljs-type">uint8_t</span> data = <span class="hljs-built_in">read</span>(addr);<br><br>    <span class="hljs-type">uint16_t</span> value = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint16_t</span>&gt;(data);<br>    <span class="hljs-type">uint16_t</span> carry_in = <span class="hljs-built_in">get_flag</span>(C) ? <span class="hljs-number">0</span> : <span class="hljs-number">1</span>;<br>    <span class="hljs-type">uint16_t</span> result = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint16_t</span>&gt;(registers.a) - value - carry_in;<br><br>    registers.a = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint8_t</span>&gt;(result &amp; <span class="hljs-number">0xFF</span>);<br><br>    <span class="hljs-built_in">set_flag</span>(N, registers.a &amp; <span class="hljs-number">0x80</span>);<br>    <span class="hljs-built_in">set_flag</span>(Z, registers.a == <span class="hljs-number">0</span>);<br>    <span class="hljs-built_in">set_flag</span>(C, result &lt; <span class="hljs-number">0x100</span>);<br>    <span class="hljs-built_in">set_flag</span>(V, ((registers.a ^ result) &amp; (registers.a ^ data) &amp; <span class="hljs-number">0x80</span>) != <span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><figure><img src="/img/nes/normal.png" alt="正常运行" /><figcaption aria-hidden="true">正常运行</figcaption></figure><p>本以为要对着这2000行代码发呆无从下手，分析一下定位问题后解决还挺快的，就是正确定位bug更难哇！</p>]]></content>
    
    
    
    <tags>
      
      <tag>debug</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>宏定义的双井号</title>
    <link href="/2024/05/17/hong-ding-yi-de-shuang-jing-hao/"/>
    <url>/2024/05/17/hong-ding-yi-de-shuang-jing-hao/</url>
    
    <content type="html"><![CDATA[<p>今日写作业（Cuda）发现老师给的框架中有一段宏定义没有看懂</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// access element (i,j) of array u with leading dimension ldu</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> V(u, i, j)       u[(i)*(ld##u) + (j)]</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> V_(u, ldu, i, j) u[(i)*(ldu)   + (j)]</span><br></code></pre></td></tr></table></figure><p>第二个<code>V_</code>很好懂，但第一个后面的<code>##</code>两个井号没有太搞懂是什么意思。</p><p>查询后发现<code>#</code>叫<strong>字符串化操作符</strong>，将宏定义中的传入参数名转换成用一对双引号括起来的参数名字符串。两个井号<code>##</code>叫做<strong>符号连接操作符</strong>，将两个标识符贴在一起形成新的标识符。</p><p>在这个例子中就是用<code>V(u, i, j)</code>中的<code>u</code>替换<code>ld##u</code>中的u。如<code>V(u, i, j)</code>会被替换为<code>u[i * ldu + j]</code>而<code>V(v, i, j)</code>则会被替换成<code>v[i * ldv +j]</code></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>寄存器清零的一些发现</title>
    <link href="/2024/05/03/ji-cun-qi-qing-ling-de-yi-xie-fa-xian/"/>
    <url>/2024/05/03/ji-cun-qi-qing-ling-de-yi-xie-fa-xian/</url>
    
    <content type="html"><![CDATA[<h1 id="问题起源">问题起源</h1><p>写编译器课的作业到最后instruction selection的部分，在对比使用Compilerexplorer的生成的x86_64汇编代码发现一个很神奇的地方就是对寄存器清零（使用立即数0）的方法。</p><p>在创建分支与进行逻辑操作时使用常数0进行比较，我的第一反应是直接使用<code>MOV $0, REG</code>的方法（<code>REG</code>指某一寄存器，下同。），但是发现Compilerexplorer会有<code>XOR REG, REG</code>的方法，于是小调研了一下两者的区别。</p><p>首先来看一下英特尔的Software Optimization Manual的3.5.1 InstructionSelection 中第7节Clearing Registers and Dependency Breaking Idioms</p><blockquote><p>Code sequences that modifies partial register can experience somedelay in its dependency chain, but can be avoided by using dependencybreaking idioms.</p></blockquote><p>在Intel Coremicro-architecture中可用下列命令将寄存器置零（亦称dependency breakingidioms或zero idioms）</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-keyword">XOR</span> REG, REG<br><span class="hljs-keyword">SUB</span> REG, REG<br><span class="hljs-keyword">XORPS</span>/PD XMMREG, XMMREG<br><span class="hljs-keyword">PXOR</span> XMMREG, XMMREG<br><span class="hljs-keyword">SUBPS</span>/PD XMMREG, XMMREG<br><span class="hljs-keyword">PSUBB</span>/W/D/Q XMMREG, XMMREG<br></code></pre></td></tr></table></figure><p>然后特别提到</p><blockquote><p>The XOR and SUB instructions can be used to clear executiondependencies on the zero evaluation of the destination register.</p></blockquote><p>之后引出Assembly/Compiler Coding Rule 32</p><blockquote><p>Use dependency-breaking-idiom instructions to set a register to 0, orto break a false dependence chain resulting from re-use of registers. Incontexts where the condition codes must be preserved, move 0 into theregister instead. This requires more code space than using XOR and SUB,but avoids setting the condition codes.</p></blockquote><p>一开始这些都没明白，但确定了直接使用<code>mov</code>指令和使用其他的指令的两个区别：</p><ol type="1"><li><strong><code>MOV</code>指令不会改变ALU的标志位，而<code>XOR</code>和<code>SUB</code>涉及算术运算会更新flag</strong></li><li><strong><code>MOV</code>指令长度相较<code>XOR</code>和<code>SUB</code>指令更长。对于立即数<code>$0</code>至少要额外空间来存下这个数</strong></li></ol><p>之后继续查询相关资料。</p><h1 id="寄存器依赖">寄存器依赖</h1><p>在指令流水线中指令会被分为若干阶段执行，指令可能会不按顺序执行。当同时执行的指令发生冲突会产生危险（hazard）。</p><p>其中有data hazards, structural hazards和controlhazards。依赖就是指data之前的依赖关系，当依赖发生问题时就会出现hazard。这里我们只看data hazards。</p><h2 id="data-hazards">Data hazards</h2><p>有三种。</p><p>read after write (RAW): true dependency</p><p>write after read (WAR): anti-dependency</p><p>write after write (WAW): output dependency</p><h3 id="read-after-write-raw">Read after write (RAW)</h3><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-symbol">i1.</span> <span class="hljs-built_in">R2</span> &lt;- <span class="hljs-built_in">R5</span> + <span class="hljs-built_in">R8</span><br><span class="hljs-symbol">i2.</span> <span class="hljs-built_in">R4</span> &lt;- <span class="hljs-built_in">R2</span> + <span class="hljs-built_in">R8</span><br></code></pre></td></tr></table></figure><p>i2如果在i1前执行会对载入的数据有问题，因为R2可能未及时更新。是真正的依赖。</p><h3 id="write-after-read-war">Write after read (WAR)</h3><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-symbol">i1.</span> <span class="hljs-built_in">R4</span> &lt;- <span class="hljs-built_in">R1</span> + <span class="hljs-built_in">R5</span><br><span class="hljs-symbol">i2.</span> <span class="hljs-built_in">R5</span> &lt;- <span class="hljs-built_in">R1</span> + <span class="hljs-built_in">R2</span><br></code></pre></td></tr></table></figure><p>i2如果在i1前执行会对R5造成影响。解决方法使用寄存器重新命名，如将i2中的R5改为其他寄存器。最有名的是Tomasulo算法。这一过程发生在硬件级别。</p><h3 id="write-after-write-waw">Write after write (WAW)</h3><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-symbol">i1.</span> <span class="hljs-built_in">R5</span> &lt;- <span class="hljs-built_in">R4</span> + <span class="hljs-built_in">R7</span><br><span class="hljs-symbol">i2.</span> <span class="hljs-built_in">R5</span> &lt;- <span class="hljs-built_in">R1</span> + <span class="hljs-built_in">R3</span><br></code></pre></td></tr></table></figure><p>同样可通过寄存器重新命名解决。</p><h1 id="partial-register与假依赖">partial register与假依赖</h1><p>依赖中只有<strong>RAW</strong>是真依赖，<strong>WAR</strong>和<strong>WAW</strong>都是假依赖。</p><p>在x86_64中寄存器可有8位、16位、32位与64位进行访问，详见下表。对于32位寄存器来说，小于等于16位的寄存器被称为partialregister。因为都是一个逻辑寄存器，只是访问大小不同，在操作时可能就会因为这一点出现假依赖的问题。</p><figure><img src="/img/register_clearing/registers.png" alt="Register names" /><figcaption aria-hidden="true">Register names</figcaption></figure><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-comment">; Example 9.1c, False dependence of partial register</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">eax</span>, [mem1] <span class="hljs-comment">; 32 bit memory operand</span><br><span class="hljs-keyword">imul</span> <span class="hljs-built_in">eax</span>, <span class="hljs-number">6</span><br><span class="hljs-keyword">mov</span> [mem2], <span class="hljs-built_in">eax</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>, [mem3] <span class="hljs-comment">; 16 bit memory operand</span><br><span class="hljs-keyword">add</span> <span class="hljs-built_in">ax</span>, <span class="hljs-number">2</span><br><span class="hljs-keyword">mov</span> [mem4], <span class="hljs-built_in">ax</span><br></code></pre></td></tr></table></figure><p>代码的原本目的是执行两项完全不相关的工作，但是第四条指令<code>mov ax, [mem3]</code>只改变了寄存器的低16位，高16位仍是前面保留下来的结果。对于Intel, AMD等公司的CPU来说，它们不会对partialregister进行重新命名，也就是第四条指令与前面用的是一个物理寄存器，这使得<code>mov ax, [mem3]</code>依赖于指令<code>imul eax, 6</code>。</p><p>另外有些CPU会对partialregister进行重新命名，可以使<code>mov ax, [mem3]</code>不依赖于<code>imul eax, 6</code>，但最后还是要把<code>imul eax, 6</code>中eax的高16位与<code>mov ax, [mem3]</code>中的ax进行组合，浪费时间。</p><h1 id="zero-idioms-dependency-breaking-idioms">Zero idioms (dependencybreaking idioms)</h1><p>在Software Optimization Manual的2.1.3 The Out-of-OrderEngine中的Renamer（寄存器重新命名器）也提到了</p><blockquote><p>Instruction parallelism can be improved by using common instructionsto clear register contents to zero. The renamer can detect them on thezero evaluation of the destination register. Use one of these dependencybreaking idioms to clear a register when possible. Since zero idioms aredetected and removed by the renamer, they have no execution latency.</p></blockquote><p>回看第一节中的说法就全明白了。</p><p>对于使用partial register导致的假依赖如果使用zeroidioms，CPU中的renamer会自动handle这一情况，对寄存器清零的同时使上下文不再依赖，同时更新ALU的flag，降低运行延时。</p><p>如果在<code>mov ax, [mem3]</code>命令前加上<code>xor eax, eax</code>，会消除因为部分更新导致的依赖。</p><h1 id="验证">验证</h1><p>对于依赖的情况不是很好验证，因为是发生在硬件层面。但对于<strong>指令长度</strong>而言就好验证多了。</p><p>首先尝试在作业的instructionselection上加了特例将<code>const 0</code>的情况使用<code>xor</code>进行处理。然后执行<code>gcc -o a --target=x86_64-apple-macos test.s</code>看生成的二进制文件大小发现并没有区别。想到我用的是M1芯片的Mac，二进制已经是转成Mac的ARM架构了，而ARM架构指令是定长的与x86_64不太一样不在本文讨论范围，于是转到ArchLinux上 进行实验。</p><p>发现使用两个不同的版本生成的二进制文件大小确实不同，使用<code>xor</code>的文件会更小一些。再用最简单方法进一步验证。</p><p>首先编写了最简单的两段汇编代码。然后使用<code>as mov.s -o mov.o</code>生成<code>.o</code>文件。再使用objdump查看反汇编内容，命令：<code>objdump -s -d mov.o &gt; mov.o.text</code>.</p><p>最终能发现使用<code>mov</code>的机器码确实会比使用<code>xor</code>的要长。单从指令上看<code>mov</code>就要多占用4字节对立即数0（32位）进行存储。</p><figure><img src="/img/register_clearing/2024-05-04-151442_hyprshot.png"alt="Screenshot of codes" /><figcaption aria-hidden="true">Screenshot of codes</figcaption></figure><h1 id="总结">总结</h1><p>在第一节中介绍的书中的assembly rule会希望大家尽可能使用zeroidioms来将寄存器清零。但如果要保持condition的flag则可以使用<code>mov</code>。最大的影响就是<code>mov</code>指令要引入常数0与12345678这种大数没有区别，指令长度会更长，造成资源浪费。</p><p>另，<code>mov</code>和<code>movq</code>后加立即数读取的是一个32位数字，然后将其扩展到64位（对于操作的寄存器是64位而言）。而<code>movabsq</code>是直接读入一个64位数字。</p><p>(在学不下习的时候什么都比作业好玩)</p><h1 id="references">References</h1><p>[1] - <ahref="https://stackoverflow.com/questions/58090417/why-does-it-take-less-bytes-to-use-xor-than-to-use-mov">https://stackoverflow.com/questions/58090417/why-does-it-take-less-bytes-to-use-xor-than-to-use-mov</a></p><p>[2] - <ahref="https://blog.eastonman.com/blog/2021/05/modern-processor/">https://blog.eastonman.com/blog/2021/05/modern-processor/</a></p><p>[3] - <ahref="https://www.intel.com/content/dam/doc/manual/64-ia-32-architectures-optimization-manual.pdf">https://www.intel.com/content/dam/doc/manual/64-ia-32-architectures-optimization-manual.pdf</a></p><p>[4] - <ahref="https://en.wikipedia.org/wiki/Hazard_(computer_architecture)#Data_hazards">https://en.wikipedia.org/wiki/Hazard_(computer_architecture)#Data_hazards</a></p><p>[5] - <ahref="https://stackoverflow.com/questions/70648350/what-is-false-dependency-in-cpu">https://stackoverflow.com/questions/70648350/what-is-false-dependency-in-cpu</a></p><p>[6] - <ahref="https://www.cnblogs.com/TaigaCon/p/7455443.html">https://www.cnblogs.com/TaigaCon/p/7455443.html</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>拉丁语笔记 1</title>
    <link href="/2024/04/12/la-ding-yu-bi-ji-1/"/>
    <url>/2024/04/12/la-ding-yu-bi-ji-1/</url>
    
    <content type="html"><![CDATA[<h1 id="chapter-1-from-learn-to-read-latin">Chapter 1 from Learn to readLatin</h1><h2 id="vocabulary">Vocabulary</h2><table><thead><tr><th>Latin Word</th><th>English Translation</th></tr></thead><tbody><tr><td><strong>agricola, agricolae</strong> m.</td><td>farmer</td></tr><tr><td><strong>anima, animae</strong> f.</td><td>life force; soul</td></tr><tr><td><strong>dea, deae</strong> f.</td><td>goddess</td></tr><tr><td><strong>fāma, fāmae</strong> f.</td><td>report, rumor; reputation, fame</td></tr><tr><td><strong>femina, feminae</strong> f.</td><td>woman; wife</td></tr><tr><td><strong>fīlia, fīliae</strong> f.</td><td>daughter</td></tr><tr><td><strong>īnsula, īnsulae</strong> f.</td><td>island</td></tr><tr><td><strong>Italia, Italiae</strong> f.</td><td>Italy</td></tr><tr><td><strong>nauta, nautae</strong> m.</td><td>sailor</td></tr><tr><td><strong>patria, patriae</strong> f.</td><td>country, homeland</td></tr><tr><td><strong>pecūnia, pecūniae</strong> f.</td><td>money</td></tr><tr><td><strong>poēta, poētae</strong> m.</td><td>poet</td></tr><tr><td><strong>puella, puellae</strong> f.</td><td>girl</td></tr><tr><td><strong>rēgīna, rēgīnae</strong> f.</td><td>queen</td></tr><tr><td><strong>via, viae</strong> f.</td><td>way, road, street, path</td></tr><tr><td><strong>ager, agrī</strong> m.</td><td>field</td></tr><tr><td><strong>deus, deī</strong> m.</td><td>god</td></tr><tr><td><strong>dominus, dominī</strong> m.</td><td>master, lord</td></tr><tr><td><strong>fīlius, fīliī</strong> m.</td><td>son</td></tr><tr><td><strong>gladius, gladiī</strong> m.</td><td>sword</td></tr><tr><td><strong>liber, librī</strong> m.</td><td>book</td></tr><tr><td><strong>puer, puerī</strong> m.</td><td>boy</td></tr><tr><td><strong>servus, servī</strong> m.</td><td>slave</td></tr><tr><td><strong>vir, virī</strong> m.</td><td>man; husband</td></tr><tr><td><strong>aurum, aurī</strong> n.</td><td>gold</td></tr><tr><td><strong>bellum, bellī</strong> n.</td><td>war</td></tr><tr><td><strong>cōnsilium, cōnsiliī</strong> n.</td><td>deliberation; plan; advice; judgment</td></tr><tr><td><strong>dōnum, dōnī</strong> n.</td><td>gift</td></tr><tr><td><strong>factum, factī</strong> n.</td><td>deed</td></tr><tr><td><strong>ferrum, ferrī</strong> n.</td><td>iron; sword</td></tr><tr><td><strong>oppidum, oppidī</strong> n.</td><td>town</td></tr><tr><td><strong>perīculum, perīculī</strong> n.</td><td>danger</td></tr><tr><td><strong>verbum, verbī</strong> n.</td><td>word</td></tr><tr><td><strong>ā, ab</strong> (prep. + abl.)</td><td>(away) from</td></tr><tr><td><strong>ad</strong> (prep. + acc.)</td><td>toward, to</td></tr><tr><td><strong>cum</strong> (prep. + abl.)</td><td>with</td></tr><tr><td><strong>dē</strong> (prep. + abl.)</td><td>(down) from; about, concerning</td></tr><tr><td><strong>ē, ex</strong> (prep. + abl.)</td><td>(out) from</td></tr><tr><td><strong>et</strong> (conj.)</td><td>and</td></tr><tr><td><strong>et...et...</strong></td><td>both...and...</td></tr><tr><td><strong>in</strong> (prep. + acc.)</td><td>into, onto; against</td></tr><tr><td><strong>in</strong> (prep. + abl.)</td><td>in, on</td></tr><tr><td><strong>ō</strong> (interj.)</td><td>O</td></tr><tr><td><strong>-que</strong> (enclitic conj.)</td><td>and</td></tr></tbody></table><p><strong>Nom.</strong> for nominative.</p><p><strong>Gen.</strong> for genitive.</p><p><strong>Dat.</strong> for dative.</p><p><strong>Acc.</strong> for accusative.</p><p><strong>Abl.</strong> for ablative.</p><p><strong>Voc.</strong> for vocative.</p><p><strong>anima, animae</strong> <em>f</em>. physical meaning, the"breath" of the wind or of a human being. By extension, it may mean thebreath of life, the force that gives an animate being life (life force).<strong>anima</strong> is used of the part of a human being that departsfrom the dead body and journeys to another life in the underworld.</p><p><strong>fāma, fāmae</strong> <em>f</em>. derives from Indo-Europeanroot "speak". It indicates primarily what is spoken publicly pr by thepeople. Basic means "talk" or "rumour".</p><p>A <strong>fāma</strong> is often told becomes a "story", and when itis passed down from generation to generation, it becomes a "tradition".A person's <strong>fāma</strong> is his or her "reputation" or "fame",can either be positive or negative. Capitalized <strong>Fāma</strong> isthe goddess Rumour.</p><p><strong>deus, deī</strong> <em>m</em>. common irregular forms in theplural.</p><table><tbody><tr><td style="text-align: left;">Nom./Voc.</td><td style="text-align: left;"><strong>deus</strong></td><td style="text-align: left;"><strong>dī</strong></td></tr><tr><td style="text-align: left;">Gen.</td><td style="text-align: left;"><strong>deī</strong></td><td style="text-align: left;"><strong>deōrum</strong> or<strong>deum</strong></td></tr><tr><td style="text-align: left;">Dat.</td><td style="text-align: left;"><strong>deō</strong></td><td style="text-align: left;"><strong>dīs</strong></td></tr><tr><td style="text-align: left;">Acc.</td><td style="text-align: left;"><strong>deum</strong></td><td style="text-align: left;"><strong>deōs</strong></td></tr><tr><td style="text-align: left;">Abl.</td><td style="text-align: left;"><strong>deō</strong></td><td style="text-align: left;"><strong>dīs</strong></td></tr></tbody></table><p>There is no vocative singular of <strong>deus</strong>. Less commonforms of the nominative/vocative plural are <strong>deī</strong> and<strong>diī</strong>. Less common form of the dative/ablative plural is<strong>deīs</strong>.</p><p><strong>dominus, dominī</strong> <em>m</em>. is cognate with theLatin word for house (<strong>domus</strong>). The original meaning ofth <strong>dominus</strong> was "master rof the house".</p><p><strong>cōnsilium, cōnsiliī</strong> <em>n.</em> the act ofdeliberating about something (deliberation), or "plan" or "intention"that results from deliberating. It may also mean the capacity todeliberate (judgement). Finally, it may refer to a group of people whodeliberate, a "council".</p><p><strong>ferrum, ferrī</strong> <em>n</em>. "iron". By the rhetoricaldevice <strong>metonymy</strong> (change of name, 转喻) it also means"sword".</p><p><strong>ā, ab</strong> (+ abl.) (away) from: <strong>ab</strong> isused before words beginning with vowels or <strong>h-</strong>. Both<strong>ā</strong> (more frequent) and <strong>ab</strong> are usedbefore words beginning with consonants.</p><p><strong>ad</strong> (+ acc.) toward, to</p><p><strong>cum</strong> (+ abl.) with</p><p><strong>dē</strong> (+ abl.) (down) from; about, concerning</p><p><strong>ē, ex</strong> (+ abl.) (out) from: 元音辅音前使用情况与<strong>ā, ab</strong> 相同</p><p><strong>in</strong> (+ acc.) into, onto; against (+ abl.) in, on</p><p><strong>et</strong> (conj.) and; <strong>et ... et ...</strong> both... and ... (adv.) even, also</p><p><strong>-que</strong> (enclitic conj.) and: used in place of thefirst <strong>et</strong> in the phrase <strong>et ... et ...</strong>by certain prose stylists (the historians Livy, Sallust, and Tacitus andby many poets. Caesar and Cicero never use <strong>-que ... et...</strong> The use of <strong>-que ... -que ...</strong> is found onlyin poetry and occasionally in the historians.</p><h2 id="five-declensions">Five declensions</h2><p>Five groups of nouns are most reliably distinguished and identifiedby the <em>genitive singular</em> ending of each declension:</p><table><thead><tr><th style="text-align: left;"></th><th style="text-align: left;"><em>Genitive Singular Ending</em></th></tr></thead><tbody><tr><td style="text-align: left;">1st</td><td style="text-align: left;"><strong>-ae</strong></td></tr><tr><td style="text-align: left;">2nd</td><td style="text-align: left;"><strong>-ī</strong></td></tr><tr><td style="text-align: left;">3rd</td><td style="text-align: left;"><strong>-is</strong></td></tr><tr><td style="text-align: left;">4th</td><td style="text-align: left;"><strong>-ūs</strong></td></tr><tr><td style="text-align: left;">5th</td><td style="text-align: left;"><strong>-eī/ēī</strong></td></tr></tbody></table><h2 id="noun-first-declension">Noun: First declension</h2><p>Case Endings of the First Declension</p><table><thead><tr><th style="text-align: left;"></th><th style="text-align: left;"><em>Singular</em></th><th style="text-align: left;"><em>Plural</em></th></tr></thead><tbody><tr><td style="text-align: left;">Nom./Voc.</td><td style="text-align: left;"><strong>-a</strong></td><td style="text-align: left;"><strong>-ae</strong></td></tr><tr><td style="text-align: left;">Gen.</td><td style="text-align: left;"><strong>-ae</strong></td><td style="text-align: left;"><strong>-ārum</strong></td></tr><tr><td style="text-align: left;">Dat.</td><td style="text-align: left;"><strong>-ae</strong></td><td style="text-align: left;"><strong>-īs</strong></td></tr><tr><td style="text-align: left;">Acc.</td><td style="text-align: left;"><strong>-am</strong></td><td style="text-align: left;"><strong>-ās</strong></td></tr><tr><td style="text-align: left;">Abl.</td><td style="text-align: left;"><strong>-ā</strong></td><td style="text-align: left;"><strong>-īs</strong></td></tr></tbody></table><p><strong>dea, deae</strong> <em>f</em>. "goddess" and <strong>fīlia,fīliae</strong> <em>f</em>. "daughter" occasionally have irregulardative and ablative plural forms: <strong>deābus</strong> and<strong>fīliābus</strong>.</p><h2 id="noun-second-declension">Noun: Second declension</h2><p>Case Endings of the Second Declension: Masculine/Feminine</p><table><thead><tr><th style="text-align: left;"></th><th style="text-align: left;"><em>Singular</em></th><th style="text-align: left;"><em>Plural</em></th></tr></thead><tbody><tr><td style="text-align: left;">Nom./Voc.</td><td style="text-align: left;"><strong>-us/--</strong></td><td style="text-align: left;"><strong>-ī</strong></td></tr><tr><td style="text-align: left;">Gen.</td><td style="text-align: left;"><strong>-ī</strong></td><td style="text-align: left;"><strong>-ōrum</strong></td></tr><tr><td style="text-align: left;">Dat.</td><td style="text-align: left;"><strong>-ō</strong></td><td style="text-align: left;"><strong>-īs</strong></td></tr><tr><td style="text-align: left;">Acc.</td><td style="text-align: left;"><strong>-um</strong></td><td style="text-align: left;"><strong>-ōs</strong></td></tr><tr><td style="text-align: left;">Abl.</td><td style="text-align: left;"><strong>-ō</strong></td><td style="text-align: left;"><strong>-īs</strong></td></tr><tr><td style="text-align: left;">Voc.</td><td style="text-align: left;"><strong>-e</strong></td><td style="text-align: left;"><strong>-ī</strong></td></tr></tbody></table><p>Case Endings of the Second Declension: Masculine/Feminine</p><table><thead><tr><th style="text-align: left;"></th><th style="text-align: left;"><em>Singular</em></th><th style="text-align: left;"><em>Plural</em></th></tr></thead><tbody><tr><td style="text-align: left;">Nom./Voc.</td><td style="text-align: left;"><strong>-um</strong></td><td style="text-align: left;"><strong>-a</strong></td></tr><tr><td style="text-align: left;">Gen.</td><td style="text-align: left;">-ī</td><td style="text-align: left;">-ōrum</td></tr><tr><td style="text-align: left;">Dat.</td><td style="text-align: left;">-ō</td><td style="text-align: left;">-īs</td></tr><tr><td style="text-align: left;">Acc.</td><td style="text-align: left;">-um</td><td style="text-align: left;"><strong>-a</strong></td></tr><tr><td style="text-align: left;">Abl.</td><td style="text-align: left;">-ō</td><td style="text-align: left;">-īs</td></tr></tbody></table>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hexo使用Python库fonttools取子集压缩字体</title>
    <link href="/2024/04/05/hexo-fluid-zhu-ti-shi-yong-python-ku-fonttools-ya-suo-zi-ti/"/>
    <url>/2024/04/05/hexo-fluid-zhu-ti-shi-yong-python-ku-fonttools-ya-suo-zi-ti/</url>
    
    <content type="html"><![CDATA[<p>博客想使用第三方字体，奈何字体体积很大，部署后发现加载速度太慢。</p><p>尝试使用Node的包font-spider进行字体压缩，但由于使用的主题（fluid）会引入第三方css，其中又会引入自己其他的css，在其中路径是<code>//at.alicdn.com/...</code>的格式，会导致font-spider出现<code>web font not found</code>和错误，说路径上的文件不存在。应该是把在线格式理解成本地格式了，故放弃使用font-spider。</p><p>之后发现font-spider是用fontmin实现的，下载安装后又出现Node的EsJs和CommonJs引入包语法不一样的问题，不想折腾直接放弃。</p><p>之后又发现Python包fonttools也可以实现字体压缩，也是用保留字体中指定文字子集的方法，下载尝试后解决问题。</p><p>fonttools安装 <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">pip3 install fonttools<br></code></pre></td></tr></table></figure></p><p>详细使用方法可 <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">pyftsubset --help<br></code></pre></td></tr></table></figure></p><p>其中一种方法是指定文件中的文本，在原字体文件夹下生成一个比原文件名多一个<code>.subset</code>的字体文件。<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">pyftsubset font-file --text-file=&lt;path&gt;<br></code></pre></td></tr></table></figure></p><p>在hexo博客生成后，简单粗暴让字体只保留<code>public/</code>文件夹下所有html文件中的文字，于是（让ChatGPT）写一个shell脚本：<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/sh</span>   <br>  <br>hexo clean  <br>hexo g  <br><span class="hljs-meta prompt_">  </span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">构建命令</span>  <br>command=&quot;pyftsubset source/fonts/字体文件.ttf&quot;  <br><span class="hljs-meta prompt_">  </span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">递归查找 HTML 文件并作为参数添加到命令中</span>  <br>find public -type f -name &quot;*.html&quot; -exec printf -- &quot;--text-file=\&quot;%s\&quot; &quot; &#123;&#125; + | xargs $command<br></code></pre></td></tr></table></figure>原字体文件保存在<code>source/fonts</code>下，在同文件夹下会生成一个<code>字体文件.subset.ttf</code>的文件。</p><p>在<code>source/css</code>下创建一个<code>custom.css</code>，将字体指定为新字体文件。<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-keyword">@font-face</span> &#123;  <br>  <span class="hljs-attribute">font-family</span>: <span class="hljs-string">&quot;字体家族名&quot;</span>;  <br>  <span class="hljs-attribute">src</span>: <span class="hljs-built_in">url</span>(<span class="hljs-string">&quot;字体文件.subset.ttf&quot;</span>) <span class="hljs-built_in">format</span>(<span class="hljs-string">&#x27;truetype&#x27;</span>),  <br>&#125;<br></code></pre></td></tr></table></figure> 在fluid主题设置<code>_config.fluid.yml</code>中指定customcss <figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">custom_css:</span> <span class="hljs-string">&quot;./css/custom.css&quot;</span><br></code></pre></td></tr></table></figure> 同样指定全局字体 <figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">font:</span>  <br>  <span class="hljs-attr">font_size:</span> <span class="hljs-string">16px</span>  <br>  <span class="hljs-attr">font_family:</span> <span class="hljs-string">字体家族名</span><br>  <span class="hljs-attr">letter_spacing:</span> <span class="hljs-number">0.</span><span class="hljs-string">02em</span>  <br>  <span class="hljs-attr">code_font_size:</span> <span class="hljs-number">85</span><span class="hljs-string">%</span><br></code></pre></td></tr></table></figure></p><p>一切搞定，每次更新后运行一下脚本，压缩后字体大小从21M降到300k。</p>]]></content>
    
    
    
    <tags>
      
      <tag>博客搭建</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>并行计算-并行程序的评估</title>
    <link href="/2024/04/02/bing-xing-ji-suan-bing-xing-cheng-xu-de-ping-gu/"/>
    <url>/2024/04/02/bing-xing-ji-suan-bing-xing-cheng-xu-de-ping-gu/</url>
    
    <content type="html"><![CDATA[<h1 id="并行执行时间方程式">并行执行时间方程式</h1><p>对于一个并行算法，除了要确定计算步数外，还需要估计通信开销。在消息传递系统中，在求解问题的整个执行时间中必须考虑发送消息的时间。并行执行时间<spanclass="math inline">\(t_p\)</span>是由两部分组成的：一个计算部分<spanclass="math inline">\(t_\text{comp}\)</span>和一个通信部分<spanclass="math inline">\(t_\text{comm}\)</span>；即有： <spanclass="math display">\[t_p = t_\text{comp} + t_\text{comm}\]</span> ## 计算时间计算时间可使用类似于顺序算法的方法通过计数计算步数加以推算。当有多个进程同时执行时，只需计数最复杂进程的计算步数。通常所有进程都完成相同的操作，所以我们只需简单地计数一个进程的计算步数。在其他的情况中，我们将需要找出并发进程中的最大计算步数。一般而言，计算步数是<spanclass="math inline">\(n\)</span>和<spanclass="math inline">\(p\)</span>的函数。即有 <spanclass="math display">\[ t_\text{comp} = f(n,p)\]</span> <spanclass="math inline">\(t_p\)</span>的时间单位与计算步的一样。</p><p>为方便起见，我们常将计算时间用消息传递分成各个部分，然后确定每个部分的计算时间。于是有<span class="math display">\[t_\text{comp}=t_\text{comp1}+t_\text{comp2}+t_\text{comp3}+...\]</span> 其中<span class="math inline">\(t_\text{comp1}\)</span>、<spanclass="math inline">\(t_\text{comp2}\)</span>、<spanclass="math inline">\(t_\text{comp3}\)</span> ...是各个部分的计算时间。</p><p>计算时间的分析通常假设所有处理器均相同且以相同速度运行。对特殊设计的计算机/多处理机来讲情况确实如此，但对机群来讲就不一定。机群的一个重要特征是计算机不必完全相同。在进行数学分析时，若考虑异构系统情况将有很大难度，因此我们的分析将假设所有计算机均是相同的。通过选择可用计算机间平衡计算负载的实现方法（负载平衡，loadbalancing）就可将不同类型的计算机考虑在内。 # 通信时间通信时间与消息的数量、消息的大小、底层的互联结构以及传送方式有关。每个消息的通信时间与许多因素有关，包括网络结构和网络竞争。作为最初的近似，我们将使用下列公式表示消息1的通信时间：<span class="math display">\[t_\text{comm}=t_\text{startup} + wt_\text{data}\]</span> 其中<spanclass="math inline">\(t_\text{startup}\)</span>为启动时间，也称<em>消息时延</em>。实际上是<strong>发送不包含数据的消息所需的时间</strong>。它包括在源进程处将消息打包以及在目的进程处将消息解包所需的时间。</p><p>术语<em>时延（latency）</em>用来描述完整的通信延时，所以这里用<em>启动</em>时间这一术语，且假设启动时间为一常数。</p><p><spanclass="math inline">\(t_\text{data}\)</span>这一项表示<strong>发送一个数据字</strong>所需的传送时间，也似它为一常数，<spanclass="math inline">\(w\)</span>则表示数据字的数目。传送速率通常以位/秒（bits/second）为单位。当数据有<spanclass="math inline">\(b\)</span>位时，就用<spanclass="math inline">\(b/t_\text{data}\)</span>位/秒来表示。</p><p>下图对此方程做了说明。实际系统中，不可能得到如此完美的线性关系。许多因素会影响通信时间，包括对通信介质的争用。方程式忽略了在实际系统中的，源和目的可能不直接链接以致于消息传递必须经过中间结点这一事实。</p><p>此外，还假设由于在包中含有非数据的信息而导致的开销也是一个常数，且是<spanclass="math inline">\(t_\text{startup}\)</span>的一部分。</p><p>最后的通信时间是一个进程中所有顺序消息的通信时间的累加和，于是有：<span class="math display">\[t_\text{comm} = t_\text{comm1} + t_\text{comm2} + t_\text{comm3} + ...\]</span> 其中，<spanclass="math inline">\(t_\text{comm1}\)</span>、<spanclass="math inline">\(t_\text{comm2}\)</span>、<spanclass="math inline">\(t_\text{comm3}\)</span> ...是各消息的通信时间。通常所有进程的通信模式是相同的，并假设是一起发生的，因而只需考虑一个进程。</p><p>由于启动时间<spanclass="math inline">\(t_\text{startup}\)</span>和数据传输时间<spanclass="math inline">\(t_\text{data}\)</span>均以计算步单位衡量，这样我们就可将<spanclass="math inline">\(t_\text{comp}\)</span>和<spanclass="math inline">\(t_\text{comm}\)</span>加在一起来提到并行执行时间<spanclass="math inline">\(t_p\)</span>。</p><h1 id="基准测试程序系数">基准测试程序系数</h1><p>一旦我们获得了顺序执行时间<spanclass="math inline">\(t_s\)</span>、计算时间<spanclass="math inline">\(t_\text{comp}\)</span>和通信时间<spanclass="math inline">\(t_\text{comm}\)</span>，我们就可以为任何给定的算法/实现确定加速系数和计算/通信比，即： <spanclass="math display">\[加速系数=\dfrac{t_s}{t_p}=\dfrac{t_s}{t_\text{comp}+t\text{comm}}\]</span> <span class="math display">\[计算/通信比=\dfrac{t_\text{comp}}{t_\text{comm}}\]</span> 两个系数均是处理器数<spanclass="math inline">\(p\)</span>和数据元素数<spanclass="math inline">\(n\)</span>的函数，并将为增加处理器数和增大问题规模的并行求解给出可扩展性的指示。</p><h1 id="时延隐藏">时延隐藏</h1><p>例. 假设一台计算机的最大运行速率为1GFLOP（每秒10亿次浮点运算）并且启动时间为1μs。则在消息启动时间内，计算机可执行1 000次浮点操作。</p><p>改善这种情况的一种方法是使<strong>通信与后续的计算重叠操作（overlap）</strong>；也就是在等待通信结束时，同时使处理器忙于有用的工作，这是所谓的<em>时延隐藏</em>。特别是非阻塞的发送例程提供了时延隐藏的可能性，但即使是（本地）阻塞发送例程也允许在等待目的进程接收消息时从事后续计算，且也许返回一个消息。</p><p>时延隐藏也可以通过将多个进程映射到一个处理器上，并使用分时机制来加以实现，当第一个进程因未完成消息传递或由于其他原因而停顿时，它就从一个进程转向另一个进程。有时称这些进程为<em>虚拟处理机</em>。在一个有<spanclass="math inline">\(p\)</span>个处理器的计算机上实现<spanclass="math inline">\(m\)</span>个进程（或虚拟机）算法被称为该计算机具有<spanclass="math inline">\(m/p\)</span>并行不完善性（parallelslackness），这里<spanclass="math inline">\(p&lt;m\)</span>。使用并行不完善性隐藏时延方依赖于从一个进程切换到另一进程的有效的方法。<em>线程</em>能提供这种的有效的机制。</p><h1 id="参考文献">参考文献</h1><p>Wilkinson, B., &amp; Allen, C. M. (2005). <em>Parallel Programming:Techniques and Applications Using Networked Workstations and ParallelComputers</em> (2nd ed.). Pearson/Prentice Hall.</p>]]></content>
    
    
    
    <tags>
      
      <tag>并行计算</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>并行计算-Performance models</title>
    <link href="/2024/04/02/bing-xing-ji-suan-performance-models/"/>
    <url>/2024/04/02/bing-xing-ji-suan-performance-models/</url>
    
    <content type="html"><![CDATA[<h1 id="acknowledgement">Acknowledgement</h1><p>The content of this post is based on a summary of the Parallelsystems (COMP8300) course at the Australian National University, which Ihave greatly benefited from. Thanks to lecturers Dr. Alberto F. Martin,Prof. John Taylor.</p><h1 id="parallel-speedup-and-efficiency">Parallel Speedup andEfficiency</h1><p><strong>Speedup （加速比）</strong> is a measure of the relativeperformance between a single and a multiprocessor parallel system whensolving a fixed size problem <span class="math display">\[S_p=\dfrac{\text{execution time on a single processor}}{\text{executiontime using } p \text{ processors}} = \dfrac{t_\text{seq}}{t_\text{par}}\]</span> <span class="math inline">\(t_\text{seq}\)</span> typicallydefined as the time for the <em>fastest</em> known sequential algorithm,sometimes (but not always) we need a different algorithm forparallelization.</p><p>Ideally, <span class="math inline">\(S_p = p\)</span> (aka linearspeedup), sometimes also super-linear speed-up (<spanclass="math inline">\(S_p&gt;p\)</span>). Examples: super-linearcomplexity; cache memory effects</p><p><strong>Efficiency</strong> is a measure of how far we are from idealspeed-up. Defined as: <span class="math display">\[E_p=\dfrac{S_p}{p}\]</span> clearly, <span class="math inline">\(0 &lt; E_p \leq1\)</span>. Optimally, <span class="math inline">\(E_p = 1\)</span></p><h1 id="parallel-overheads">Parallel Overheads</h1><p>Why cannot we expect <span class="math inline">\(S_p = p\)</span> forarbitrarily large <span class="math inline">\(p\)</span> ?Parallelization-related overheads (examples): - interprocessorcommunication and synchronization - idling (caused typically by loadimbalance, data dependencies, serial parts) - excess computation (e.g.,higher #iters. with p, communication-avoiding algs)</p><figure><img src="/img/parallel/overheads.png" alt="Execution time" /><figcaption aria-hidden="true">Execution time</figcaption></figure><h2 id="embarrassingly-parallel">Embarrassingly parallel</h2><p>A problem that can be solved without communication is called<strong>embarrassingly parallel</strong>. Clearly, will have <spanclass="math inline">\(E_p \approx 1\)</span> for large <spanclass="math inline">\(p\)</span>. However, even under this scenario<span class="math inline">\(E_p\)</span> will always drop for some(large) <span class="math inline">\(p\)</span> due to resourceunderutilization caused by very little data winded up on eachprocessor.</p><h1 id="scalability">Scalability</h1><p><strong>Scalability（可扩展性）</strong> is a very broad term, usedin many different contexts, which relates to the ability of a parallelsystem (algorithm + code + hardware) to exploit efficiently increasingcomputational resources ## Hardware scalability Does increasing the sizeof the hardware give increased performance? e.g. aggregated memorybandwidth is typically limited as we scale <spanclass="math inline">\(p\)</span> in shared-memory multiprocessors.</p><h2 id="algorithm-scalability">Algorithm scalability</h2><p>At which rate does the complexity of an algorithm (number ofoperations and memory) grow with increasing problem size? Example: fortwo dense <span class="math inline">\(N\times N\)</span> matrices,doubling hte value of <span class="math inline">\(N\)</span> increasesthe cost of matrix addition by a factor of 4, but the cost of matrixmultiplication by a factor of <span class="math inline">\(8\)</span>(i.e. <span class="math inline">\(O(N^2)\)</span> versus <spanclass="math inline">\(O(N^3)\)</span> complexity)</p><h2 id="strong-parallel-scalability">Strong parallel scalability</h2><p>At which rate the efficiency of a parallel algorithm decays withincreasing number of processors and fixed problem size?</p><h2 id="weak-parallel-scalability-previous-two-combined">Weak parallelscalability (Previous two combined)</h2><p>At which rate the efficiency of parallel algorithm decays as weincrease BOTH the number of processors and problem size?</p><h1 id="amdahls-law">Amdahl's Law</h1><h2 id="definition">Definition</h2><p>Considers "sequential parts" as the only source of overhead Let <spanclass="math inline">\(f\)</span> the (sequential) fraction of acomputation that cannot be split into parallel tasks. Then, max speed upachievable for arbitrary large <span class="math inline">\(p\)</span> is<span class="math inline">\(\dfrac{1}{f}\)</span>. <spanclass="math display">\[t_\text{par}=ft_\text{seq}+\dfrac{(1-f)t_\text{seq}}{p}\]</span> <span class="math display">\[S_p=\dfrac{t_\text{seq}}{t_\text{par}}=\dfrac{p}{pf+(1-f)}\]</span> $$\lim_{{p \to \infty}} S_p = \dfrac{1}{f}$$</p><p><img src="/img/parallel/Amdahl_1.png" alt="Amdahl&#39;s law" /><imgsrc="/img/parallel/Amdahl_2.png" alt="Amdahl&#39;s law" /> It is a<strong>strong scaling</strong> law, assumeing fixed problem size. #Gustafson's Law Amdahl's law was thought to show that large <spanclass="math inline">\(p\)</span> would never pay off, however, itassumes fixed problem size executed on more and more processors. Inpractice, this is not the case. One typically tailors problem size to<span class="math inline">\(p\)</span> (weak scaling).</p><p>A more realistic assumption is that parallel fraction can bearbitrarily extended.</p><p>Assume that the sequential portion of a parallel code is independenton <span class="math inline">\(p\)</span>, and that the problem size canbe scaled s.t. the parallelizable portion is <spanclass="math inline">\(p\)</span> times larger. Then, the scaledspeed-up:</p><p><span class="math display">\[S_\text{scaled p} = \dfrac{T_\text{scaledseq}}{T_\text{par}}=\dfrac{T_\text{seq}f+pT_\text{seq}(1-f)}{T_\text{seq}f+T_\text{seq}(1-f)}= \dfrac{f+p(1-f)}{f+(1-f)}=f+p(1-f)=p-f(p-1)\]</span> is now an unbounded linear function with <spanclass="math inline">\(p\)</span> (with slope depending of <spanclass="math inline">\(f\)</span>)</p><p>It is a <strong>weak scaling</strong> law, assuming problem sizescaled in proportion with <span class="math inline">\(p\)</span>.</p><blockquote><p>作为对比，阿姆德尔定律将单个处理器的执行时间作为定量跟并行执行时间相比。因此阿姆德尔定律是基于固定的问题规模提出的，它假设程序的整体工作量不会随着机器规模（也就是处理器数量）而改变。古斯塔夫森定律补充了阿姆德尔定律没有考虑解决问题所需的资源总量的不足。古斯塔夫森定律解决了这个问题，它表明设定并行解决方案所允许耗费的时间的最佳方式是考虑所有的计算资源和基于这类信息。from https://blog.imkasen.com/parallel-performance-metrics/</p></blockquote><h1 id="measuring-time">Measuring Time</h1><p>In order to evaluate performance of parallel algorithms we need toaccurately measure computation times.</p><p>Broadly speaking, there are two kind of times: <strong>wall clocktime</strong> (i.e. elapsed time) and <strong>CPU time</strong></p><blockquote><p><strong>Walltime</strong> is the actual time taken from the start ofa computer program to the end. <strong>CPU time</strong> measures onlythe time during which the processor is actively working on a certaintask or process. fromhttps://en.wikipedia.org/wiki/Elapsed_real_time</p></blockquote><p>Two important timer parameters are <strong>timer resolution (<spanclass="math inline">\(t_R\)</span>)</strong> and <strong>overhead(<spanclass="math inline">\(t_O\)</span>)</strong> <spanclass="math inline">\(t_R\)</span> is the smallest unit of time that canbe accurately measured by the timer - the lower the <spanclass="math inline">\(t_R\)</span> the higher the resolution - if theevent to be time is shorter than timer resolution, we can't measureit</p><p><span class="math inline">\(t_O\)</span> relates to the instructionswhich are executed and included in the measured time and not strictlyrelated toe the event being measured.</p><p><span class="math inline">\(t_R\)</span> and <spanclass="math inline">\(t_O\)</span> can be estimated measuring(differences between) repeated calls to a <strong>timerfunction</strong>.</p><p><code>MPI_Wtick()</code> shows the resolution.<code>MPI_Wtime()</code> returns an elapsed time on the callingprocessor.</p><p>The following code tests the resolution and overhead of<code>MPI_Wtime()</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">double</span> *time = (<span class="hljs-type">double</span> *)<span class="hljs-built_in">calloc</span>(num_measurements, <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">double</span>));<br><span class="hljs-type">double</span> avg = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; num_measurements; i++) &#123;<br><span class="hljs-comment">// Measure the time twice in quick succession </span><br><span class="hljs-type">double</span> start = MPI_Wtime(); <br><span class="hljs-type">double</span> end = MPI_Wtime(); <br>time[i] = end - start; <br>avg += (<span class="hljs-type">double</span>) time[i]; <br>&#125; <br>avg = avg / num_measurements; <br><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;First 200 timings:\n&quot;</span>); <br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">20</span>; j++) &#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%.1e &quot;</span>, time[i * <span class="hljs-number">20</span> + j]);<br>&#125; <br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>&#125; <br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Average: %.2e us\n&quot;</span>, avg);<br></code></pre></td></tr></table></figure><p>We got a sample output like: <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c">First <span class="hljs-number">200</span> timings:<br><span class="hljs-number">1.8e-07</span> <span class="hljs-number">3.9e-08</span> <span class="hljs-number">2.4e-08</span> <span class="hljs-number">2.7e-08</span> <span class="hljs-number">2.5e-08</span> <span class="hljs-number">2.5e-08</span> <span class="hljs-number">2.6e-08</span> <span class="hljs-number">2.5e-08</span><br><span class="hljs-number">2.5e-08</span> <span class="hljs-number">2.6e-08</span> <span class="hljs-number">2.4e-08</span> <span class="hljs-number">2.4e-08</span> <span class="hljs-number">2.6e-08</span> <span class="hljs-number">2.4e-08</span> <span class="hljs-number">2.5e-08</span> <span class="hljs-number">2.7e-08</span><br><span class="hljs-number">2.5e-08</span> <span class="hljs-number">2.4e-08</span> <span class="hljs-number">2.6e-08</span> <span class="hljs-number">2.6e-08</span> <span class="hljs-number">2.4e-08</span> <span class="hljs-number">2.7e-08</span> <span class="hljs-number">2.6e-08</span> <span class="hljs-number">2.4e-08</span><br><span class="hljs-number">2.6e-08</span> <span class="hljs-number">2.6e-08</span> <span class="hljs-number">2.4e-08</span> <span class="hljs-number">2.7e-08</span> <span class="hljs-number">2.7e-08</span> <span class="hljs-number">2.4e-08</span> <span class="hljs-number">2.5e-08</span> <span class="hljs-number">2.6e-08</span><br><span class="hljs-number">2.4e-08</span> <span class="hljs-number">2.6e-08</span> <span class="hljs-number">2.6e-08</span> <span class="hljs-number">2.5e-08</span> <span class="hljs-number">2.6e-08</span> <span class="hljs-number">2.6e-08</span> <span class="hljs-number">2.4e-08</span> <span class="hljs-number">2.7e-08</span><br><span class="hljs-number">2.7e-08</span> <span class="hljs-number">2.4e-08</span> <span class="hljs-number">2.5e-08</span> <span class="hljs-number">2.6e-08</span> <span class="hljs-number">2.4e-08</span> <span class="hljs-number">2.6e-08</span> <span class="hljs-number">2.7e-08</span> <span class="hljs-number">2.5e-08</span><br><span class="hljs-number">2.6e-08</span> <span class="hljs-number">2.6e-08</span> <span class="hljs-number">2.3e-08</span> <span class="hljs-number">2.5e-08</span> <span class="hljs-number">2.6e-08</span> <span class="hljs-number">2.4e-08</span> <span class="hljs-number">2.5e-08</span> <span class="hljs-number">2.6e-08</span><br><span class="hljs-number">2.4e-08</span> <span class="hljs-number">2.4e-08</span> <span class="hljs-number">2.6e-08</span> <span class="hljs-number">2.4e-08</span> <span class="hljs-number">2.5e-08</span> <span class="hljs-number">2.7e-08</span> <span class="hljs-number">2.4e-08</span> <span class="hljs-number">2.4e-08</span><br><span class="hljs-number">2.6e-08</span> <span class="hljs-number">2.4e-08</span> <span class="hljs-number">2.5e-08</span> <span class="hljs-number">2.6e-08</span> <span class="hljs-number">2.4e-08</span> <span class="hljs-number">2.4e-08</span> <span class="hljs-number">2.7e-08</span> <span class="hljs-number">2.4e-08</span><br><span class="hljs-number">2.4e-08</span> <span class="hljs-number">2.6e-08</span> <span class="hljs-number">2.4e-08</span> <span class="hljs-number">2.5e-08</span> <span class="hljs-number">2.6e-08</span> <span class="hljs-number">2.4e-08</span> <span class="hljs-number">2.5e-08</span> <span class="hljs-number">2.6e-08</span><br><span class="hljs-number">2.4e-08</span> <span class="hljs-number">2.4e-08</span> <span class="hljs-number">2.6e-08</span> <span class="hljs-number">2.5e-08</span> <span class="hljs-number">2.4e-08</span> <span class="hljs-number">2.6e-08</span> <span class="hljs-number">2.4e-08</span> <span class="hljs-number">2.5e-08</span><br><span class="hljs-number">2.6e-08</span> <span class="hljs-number">2.6e-08</span> <span class="hljs-number">2.5e-08</span> <span class="hljs-number">2.6e-08</span> <span class="hljs-number">2.6e-08</span> <span class="hljs-number">2.5e-08</span> <span class="hljs-number">2.7e-08</span> <span class="hljs-number">2.6e-08</span><br><span class="hljs-number">2.5e-08</span> <span class="hljs-number">2.6e-08</span> <span class="hljs-number">2.6e-08</span> <span class="hljs-number">2.5e-08</span> <span class="hljs-number">2.6e-08</span> <span class="hljs-number">2.7e-08</span> <span class="hljs-number">2.5e-08</span> <span class="hljs-number">2.7e-08</span><br><span class="hljs-number">2.7e-08</span> <span class="hljs-number">2.4e-08</span> <span class="hljs-number">2.6e-08</span> <span class="hljs-number">2.6e-08</span> <span class="hljs-number">2.4e-08</span> <span class="hljs-number">2.6e-08</span> <span class="hljs-number">2.6e-08</span> <span class="hljs-number">2.5e-08</span><br><span class="hljs-number">2.6e-08</span> <span class="hljs-number">2.6e-08</span> <span class="hljs-number">2.4e-08</span> <span class="hljs-number">2.6e-08</span> <span class="hljs-number">2.5e-08</span> <span class="hljs-number">2.4e-08</span> <span class="hljs-number">2.7e-08</span> <span class="hljs-number">2.7e-08</span><br><span class="hljs-number">2.5e-08</span> <span class="hljs-number">2.4e-08</span> <span class="hljs-number">2.6e-08</span> <span class="hljs-number">2.5e-08</span> <span class="hljs-number">2.4e-08</span> <span class="hljs-number">2.6e-08</span> <span class="hljs-number">2.4e-08</span> <span class="hljs-number">2.5e-08</span><br><span class="hljs-number">2.6e-08</span> <span class="hljs-number">2.3e-08</span> <span class="hljs-number">2.5e-08</span> <span class="hljs-number">2.6e-08</span> <span class="hljs-number">2.5e-08</span> <span class="hljs-number">2.4e-08</span> <span class="hljs-number">2.6e-08</span> <span class="hljs-number">2.4e-08</span><br><span class="hljs-number">2.4e-08</span> <span class="hljs-number">2.6e-08</span> <span class="hljs-number">2.4e-08</span> <span class="hljs-number">2.4e-08</span> <span class="hljs-number">2.6e-08</span> <span class="hljs-number">2.5e-08</span> <span class="hljs-number">2.5e-08</span> <span class="hljs-number">2.6e-08</span><br><span class="hljs-number">2.4e-08</span> <span class="hljs-number">2.3e-08</span> <span class="hljs-number">2.6e-08</span> <span class="hljs-number">2.4e-08</span> <span class="hljs-number">2.4e-08</span> <span class="hljs-number">2.6e-08</span> <span class="hljs-number">2.4e-08</span> <span class="hljs-number">2.4e-08</span><br><span class="hljs-number">2.7e-08</span> <span class="hljs-number">2.7e-08</span> <span class="hljs-number">2.5e-08</span> <span class="hljs-number">2.6e-08</span> <span class="hljs-number">2.6e-08</span> <span class="hljs-number">2.5e-08</span> <span class="hljs-number">2.6e-08</span> <span class="hljs-number">2.6e-08</span><br><span class="hljs-number">2.5e-08</span> <span class="hljs-number">2.7e-08</span> <span class="hljs-number">2.7e-08</span> <span class="hljs-number">2.5e-08</span> <span class="hljs-number">2.6e-08</span> <span class="hljs-number">2.6e-08</span> <span class="hljs-number">2.5e-08</span> <span class="hljs-number">2.6e-08</span><br><span class="hljs-number">2.6e-08</span> <span class="hljs-number">2.5e-08</span> <span class="hljs-number">2.7e-08</span> <span class="hljs-number">2.6e-08</span> <span class="hljs-number">2.4e-08</span> <span class="hljs-number">2.5e-08</span> <span class="hljs-number">2.6e-08</span> <span class="hljs-number">2.4e-08</span><br><span class="hljs-number">2.6e-08</span> <span class="hljs-number">2.5e-08</span> <span class="hljs-number">2.4e-08</span> <span class="hljs-number">2.7e-08</span> <span class="hljs-number">2.7e-08</span> <span class="hljs-number">2.4e-08</span> <span class="hljs-number">2.6e-08</span> <span class="hljs-number">2.6e-08</span><br><span class="hljs-number">2.4e-08</span> <span class="hljs-number">2.6e-08</span> <span class="hljs-number">2.7e-08</span> <span class="hljs-number">2.4e-08</span> <span class="hljs-number">2.7e-08</span> <span class="hljs-number">2.6e-08</span> <span class="hljs-number">2.4e-08</span> <span class="hljs-number">2.5e-08</span><br><span class="hljs-number">2.6e-08</span> <span class="hljs-number">2.5e-08</span> <span class="hljs-number">2.5e-08</span> <span class="hljs-number">2.7e-08</span> <span class="hljs-number">2.4e-08</span> <span class="hljs-number">2.4e-08</span> <span class="hljs-number">2.5e-08</span> <span class="hljs-number">2.4e-08</span><br>Average: <span class="hljs-number">2.47e-08</span> us<br></code></pre></td></tr></table></figure></p><p>So we can read off the average overhead to be <code>2.47e-8</code>seconds.</p>]]></content>
    
    
    
    <tags>
      
      <tag>并行计算</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>并行计算-Hardware</title>
    <link href="/2024/03/26/bing-xing-ji-suan-hardwares/"/>
    <url>/2024/03/26/bing-xing-ji-suan-hardwares/</url>
    
    <content type="html"><![CDATA[<h1 id="acknowledgement">Acknowledgement</h1><p>The content of this post is based on a summary of the Parallelsystems (COMP8300) course at the Australian National University, which Ihave greatly benefited from. Thanks to lecturers Dr. Alberto F. Martin,Prof. John Taylor.</p><h1 id="hardware">Hardware</h1><h2 id="single-processor-design">Single processor design</h2><h3 id="instruction-pipelining-single-instruction-issue">Instructionpipelining (Single instruction issue)</h3><p>Break instructions into <span class="math inline">\(k\)</span> stageseach that are overlapped in time.</p><p>e.g. (<span class="math inline">\(k = 5\)</span> stages)</p><p><strong>FI</strong> = fetch instruction</p><p><strong>DI</strong> = decode instruction</p><p><strong>FO</strong> = fetch operand</p><p><strong>EX</strong> = execute instruction</p><p><strong>WB</strong> = write back</p><p>Ideally, one gets <span class="math inline">\(k\)</span>-wayasymptotic parallelism speedup.</p><p>However, hard to maximize utilization in practice: - Constrained bydependencies among instructions; CPU must ensure result is the same asif no pipelining. - FO &amp; WB stages may involve memory accesses andmy possibly stall hte pipeline. - conditional branch instructions areproblematic: the wrong guess may require flushing succeedinginstructions from the pipeline and rolling back</p><h3 id="super-scalar-execution-multiple-instruction-issue">Super-scalarexecution (Multiple instruction issue)</h3><p>Simple idea: Increase execution rate by using <spanclass="math inline">\(w\ge2\)</span> (i.e., multiple) pipelines</p><p><span class="math inline">\(w\)</span> (mutually independent)instructions are (tried to be) piped in parallel at each cycle</p><p>Ideally it offers <span class="math inline">\(kw\)</span>-wayparallelism</p><p>However, a number of extra challenges arise: - Increase complexity:HW has to be able to resolve dependencies at runtime before issuingsimultaneously several instructions - Some of the functional units mightbe shared by the pipelines (aka resource dependencies) - As a result, ?TODO</p><p>Some remedies: pipeline feedback, branch prediction + speculativeexecution(推测执行), out-of-order execution (乱序执行 OOO) ,compilers</p><h3 id="limitations-of-instruction-level-parallelism-ilp">Limitations ofinstruction-level parallelism (ILP)</h3><p>CPU does a lot of wasted work that can just not be written back dueto branch mis-predictions.</p><h3 id="limitations-of-memory-system-performance">Limitations of memorysystem performance</h3><p>Memory <strong>latency</strong> and <strong>bandwidth</strong> arecritical performance issues - caches: reduce latency and provideimproved cache to CPU bandwidth - multiple memory banks: improvebandwidth (by parallel access)</p><p>Cache memory is effective because algorithms often use data that: -was recently accessed from memory (<strong>temporal locality</strong>) -was close to other recently accessed data (<strong>spatiallocality</strong>)</p><h3 id="going-explicitly-parallel">Going explicitly parallel</h3><ul><li>Performance of single processor is irremediably limited by clockrate</li><li>Clock rate in turn limited by power consumption, transistorswitching time, etc.</li><li>ILP allows multiple instructions at once, but it is limited bydependencies</li><li>Many problems are inherently distributed/exhibit potentialparallelism</li></ul><h2 id="parallel-hardware">Parallel hardware</h2><h3 id="overview">Overview</h3><ul><li>Flynn's taxonomy of parallel processors (1966, 1972)<ul><li>(SISD/SIMD/)SIMD/MIMD</li></ul></li><li><strong>Message-passing</strong> versus <strong>shared-address spaceprogramming</strong></li><li><strong>UMA (Uniform memory access)</strong> versus <strong>NUMAshared-memory computers</strong></li><li>Dynamic/static networks</li><li>Evaluating cost and performance of static networks</li></ul><h3 id="simd-and-mimd-in-flynns-taxonomy">SIMD and MIMD in Flynn'staxonomy</h3><h4 id="simd">SIMD</h4><p>also known as data parallel or vector processors (very popular in the70s and 80s)</p><p>examples: GPUs; SPEs on Sony's PS3 IBM CellBE</p><p>perform their best with structured (regular) computations (e.g. imageprocessing)</p><h4 id="mimd">MIMD</h4><p>examples: quad-core PC; 2x24-core Xeon CPUS</p><figure><img src="/img/parallel/SIMD_MIMD.png" alt="SIMD and MIMD" /><figcaption aria-hidden="true">SIMD and MIMD</figcaption></figure><p>Most successful model for parallel architectures - more generalpurpose than SIMD, can be built out of off-the-shelf components - extraburden to programmer</p><p>Some challenges for MIMD machines - scheduling: efficient allocationof processors to tasks in a dynamic fashion - synchronization: preventprocessors accessing the same data simultaneously - interconnect design:processor to memory and processor to processor interconnects. Also, I/Onetwork - often processors dedicated to I/O devices - overhead:inevitably there is some overhead associated with coordinatingactivities between processors, e.g. resolve contention for resources -partitioning: partitioning a computation/algorithm into concurrent tasksmight not be trivial and require algorithm redesign and/or significantprogrammign efforts</p><h3 id="logical-classification-of-parallel-computers">Logicalclassification of parallel computers</h3><ul><li>Message-passing (distributed address space) parallel computers</li><li>Shared address space parallel computers</li></ul><h3 id="physical-classification">Physical classification</h3><ul><li>Shared-memory multiple processors</li><li>Distributed-memory multiple processors</li></ul><h3 id="shared-address-space">Shared address space</h3><p><strong>UMA</strong> and <strong>NUMA</strong></p><p>example: QuadCore laptop</p><h4 id="uma">UMA</h4><figure><img src="/img/parallel/UMA_NUMA.png" alt="UMA and NUMA" /><figcaption aria-hidden="true">UMA and NUMA</figcaption></figure>]]></content>
    
    
    
    <tags>
      
      <tag>并行计算</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>并行计算-Introduction</title>
    <link href="/2024/03/26/bing-xing-ji-suan-introduction/"/>
    <url>/2024/03/26/bing-xing-ji-suan-introduction/</url>
    
    <content type="html"><![CDATA[<h1 id="acknowledgement">Acknowledgement</h1><p>The content of this post is based on a summary of the Parallelsystems (COMP8300) course at the Australian National University, which Ihave greatly benefited from. Thanks to lecturers Dr. Alberto F. Martin,Prof. John Taylor.</p><h1 id="introduction">Introduction</h1><h2 id="parallel-computing-concept-and-rationale">Parallel computing:concept and rationale</h2><h3 id="the-idea">The idea:</h3><p>Split computation into tasks that can be executed simultaneously ondiffrerent processors.</p><h3 id="motivation">Motivation:</h3><p><strong>Speed</strong> at a cost-effective price.</p><p>Reduce the time to solution to acceptable levels.</p><p>Tackle larger-scale.</p><p>Keep power consumption and heat dissipation under control.</p><h3 id="parallel-programming">Parallel programming:</h3><p>the art of writing the parallel code ### Parallel computer: thehardware on which we run our parallel code</p><h2 id="scales-of-parallelism">Scales of parallelism</h2><p>(* requires significant parallel programming effort) ### Within aCPU/core: pipelined instruction execution, multiple instruction issue(super-scalar 超标量), other forms of instruction level parallelism,SIMD (Single Instruction Multiple Data) units*</p><h3 id="within-a-chip">Within a chip:</h3><p>multiple cores<em>, hardware multithreading</em>, accelerator units*(with multiple cores), transactional memory (事务内存)*</p><h3 id="within-a-node">Within a node:</h3><p>multiple sockets* (CPU chips), interleaved memory access (multipleDRAM chips), disk block striping / RAID (multiple disks)</p><h3 id="within-s-san-system-area-network">Within s SAN (system areanetwork):</h3><p>multiple nodes* (clusters, typical supercomputers), parallelfilesystems</p><h3 id="within-the-internet">Within the internet:</h3><p>grid/cloud computing*</p><h2 id="moores-law-dennard-scaling">Moore's Law &amp; DennardScaling</h2><p>Two "laws" underpin exponential performance increase ofmicroprocessors</p><h3 id="moores-law">Moore's Law</h3><blockquote><p>Transistor density will double approximately every two years.</p></blockquote><h3 id="dennard-scaling">Dennard Scaling</h3><blockquote><p>As MOSFET features shrink. switching time and power consumption willfall proportionately.</p></blockquote><blockquote><p>MOSFET（Metal Oxide Semiconductor Field EffectTransistor-金属氧化物半导体场效应晶体管）</p></blockquote><p>The (dynamic) power consumption of a chip can be modelled as: <spanclass="math display">\[P = QfCV^2\]</span> where <strong><em>Q</em></strong> # of transistors,<strong><em>f</em></strong> frequency, <strong><em>C</em></strong>capacitance, and <strong><em>V</em></strong> voltage apply.</p><h4 id="dennards-scaling-law-until-early-2000s">Dennard's scaling law(until early 2000s)</h4><p>According to Dennard's law, if we scale feature size down by a factorof <span class="math inline">\(\dfrac{1}{\kappa}\)</span>, we can scaleup frequency by <span class="math inline">\(\kappa\)</span>, and scaledown the capacitance and voltage by <spanclass="math inline">\(\dfrac{1}{\kappa}\)</span>, resulting in a<strong>reduced</strong> power consumption of assuming <spanclass="math inline">\(Q_\kappa = \kappa^2Q_0\)</span> : <spanclass="math display">\[P_0 = Q_0f_0C_0V_0^2\to Q_\kappa f_\kappa C_\kappa V_\kappa^2 = Q_0(\kappa f_0)(\dfrac{1}{\kappa}C_0)(\dfrac{1}{\kappa}V_0)^2 =(\dfrac{1}{\kappa^2})P_0\]</span> If we allow ourselves to keep <spanclass="math inline">\(P_\kappa\)</span> a constance, the number oftransistors <span class="math inline">\(Q_\kappa\)</span> we can fit onthe same chip is: <span class="math display">\[Q_\kappa = \kappa^2 Q_0\]</span> As long as we keep scaling feature size down by <spanclass="math inline">\(\dfrac{1}{\kappa}\)</span>, we can fit <spanclass="math inline">\(\kappa^2\)</span> more transistors on the samechip, increase their frequency by <spanclass="math inline">\(\kappa\)</span>, and use the same power asbefore.</p><h4 id="the-end-of-dennard-scaling-and-uni-processor-era-2002-2004">Theend of Dennard scaling and uni-processor era (2002-2004)</h4><p>With feature size below <span class="math inline">\(\approx100nm\)</span> (nowadays around <span class="math inline">\(\approx 10mn\)</span>), we have that: <span class="math display">\[P = QfCV^2 + VI_{\text{leakage}}\]</span> (Note: for "large enough" feature size, the term <strong><spanclass="math inline">\(VI_{\text{leakage}}\)</span></strong> isnegligible.)</p><p>Unfortunately, <spanclass="math inline">\(I_{\text{leakage}}\)</span> grows exponentiallywith downscaled <span class="math inline">\(V\)</span> as we decreasefeature size by <span class="math inline">\(\dfrac{1}{\kappa}\)</span>.Thus, the term <span class="math inline">\(VI_{\text{leakage}}\)</span>blows up and dominates power consumption.</p><p>To keep power under control, large number of transistors are switchedoff (dark silicon effect), operated at lower frequencies (dim siliconeffect) or organized in different ways.</p><h2 id="why-parallel-programming-is-hard">Why parallel programming ishard</h2><ul><li>Writing (correct and efficient) parallel programs is hard</li><li>Getting (close to ideal) speed up is hard. Overheads include:<ul><li>idling (e.g. caused by load unbalance, synchronization, serialsections, etc.)</li><li>redundant / extra operations when splitting a computation intotasks</li><li>communication time among processes</li></ul></li><li>Amdahl's Law (阿姆达尔定律):<ul><li>Let <span class="math inline">\(f\)</span> the fraction of acomputation that cannot be split into parallel tasks. Then, max speed upachievable for arbitraty large <span class="math inline">\(p\)</span>processors is <span class="math inline">\(\dfrac{1}{f}\)</span>.</li></ul></li></ul><p><ahref="https://hackernoon.com/zh/%E6%B7%B1%E5%85%A5%E7%A0%94%E7%A9%B6%E9%98%BF%E5%A7%86%E8%BE%BE%E5%B0%94%E5%AE%9A%E5%BE%8B%E5%92%8C%E5%8F%A4%E6%96%AF%E5%A1%94%E5%A4%AB%E6%A3%AE%E5%AE%9A%E5%BE%8B">阿姆达尔定律</a></p><ul><li>Counterargument (Gustafson's Law):<ul><li><span class="math inline">\(1-f\)</span> is not fixed, but increaseswith the data/problem size <span class="math inline">\(N\)</span></li><li>This law says that increase of problem size for large machines canretain scalability with respect to the number of processors.</li></ul></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>并行计算</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>记第一次帮别人debug Node.js的经历</title>
    <link href="/2024/03/23/ji-di-yi-ci-bang-bie-ren-debug-node-js-de-jing-li/"/>
    <url>/2024/03/23/ji-di-yi-ci-bang-bie-ren-debug-node-js-de-jing-li/</url>
    
    <content type="html"><![CDATA[<p>学校有门项目课（非常水），接手了上一组的（垃圾）代码，用electron和Node.js写的。</p><p>（拜）读了一下午代码终于理清逻辑了，写的真的是乱七八糟，1000行代码放一个Js里，也是服了。大概给分了下组，然后在此基础上写了个认证缓存也很快就写完了。</p><p>另个同学要加一个新的日历视图进去，弄半天弄不好找我来debug。</p><p>他是要在显示界面上引入第三方包，于是在js里写的</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> <span class="hljs-title class_">FullCalendar</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;@fullcalendar/core&#x27;</span>);<br><span class="hljs-keyword">const</span> dayGridPlugin = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;@fullcalendar/daygrid&#x27;</span>);<br></code></pre></td></tr></table></figure><p>运行后按command+shift+i查看控制台，错误：</p><p><code>dashboard.js:1 Uncaught ReferenceError: require is not defined</code></p><p>疯狂谷歌，发现是因为electron是有两个进程，一个main进程一个renderer进程。默认main进程是使用的Node.js，而renderer进程是无法使用Node的，所以就会出现require无法使用的情况。</p><p>解决：</p><p>在main.js创建窗口的时候加入两个新的开关 <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript">mainWindow = <span class="hljs-keyword">new</span> <span class="hljs-title class_">BrowserWindow</span>(&#123;<br>    <span class="hljs-attr">width</span>: <span class="hljs-number">800</span>,<br>    <span class="hljs-attr">height</span>: <span class="hljs-number">600</span>,<br>    <span class="hljs-attr">webPreferences</span>: &#123; <br><span class="hljs-attr">nodeIntegration</span>: <span class="hljs-literal">true</span>,<span class="hljs-comment">// 打开允许在renderer进程使用node</span><br>        <span class="hljs-attr">contextIsolation</span>: <span class="hljs-literal">false</span>,<span class="hljs-comment">// 关闭上下文隔离</span><br>        <span class="hljs-attr">preload</span>: path.<span class="hljs-title function_">join</span>(__dirname, <span class="hljs-string">&quot;preload.js&quot;</span>) &#125;,<br>&#125;);<br><br></code></pre></td></tr></table></figure>之前的代码是开启上下文隔离的，官方解释</p><blockquote><p>上下文隔离功能将确保您的 预加载脚本 和 Electron的内部逻辑运行在所加载的 <ahref="https://www.electronjs.org/zh/docs/latest/api/web-contents">webcontent</a>网页之外的另一个独立的上下文环境里。</p></blockquote><p>为了安全在Electron 20之后也是默认开启的，但为了引入只能先关闭了。</p><p>在之前开启隔离的时候，上下文通信是使用<code>ContextBridge</code>实现api传递的</p><p>例： <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript">contextBridge.<span class="hljs-title function_">exposeInMainWorld</span>(<span class="hljs-string">&#x27;api_name&#x27;</span>, &#123;<br>    <span class="hljs-attr">sendLoginMessage</span>: <span class="hljs-function">() =&gt;</span> &#123;<br>        ipcRenderer.<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;LOGIN&#x27;</span>);<br>    &#125;,<br><span class="hljs-comment">// other apis</span><br>&#125;);<br><br></code></pre></td></tr></table></figure>关闭隔离后<code>ContextBridge</code>就无法使用了，改为 <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">window</span>.<span class="hljs-property">api_name</span> = &#123;<br>    <span class="hljs-attr">sendLoginMessage</span>: <span class="hljs-function">() =&gt;</span> &#123;<br>        ipcRenderer.<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;LOGIN&#x27;</span>);<br>    &#125;,<br><span class="hljs-comment">// other apis</span><br>&#125;);<br></code></pre></td></tr></table></figure></p><p>新问题：</p><p>运行后之前的（垃圾）代码有些属性会说undefined。错误信息<code>Uncaught TypeError: Cannot read properties of undefined (reading 'email')</code></p><p>代码： <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">isNoteSaved</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">var</span> file = &#123;<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-attr">currentEmail</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">email</span>.<span class="hljs-property">textContent</span><br>  &#125;<br>  <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure></p><p>定义在</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> email = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;email&quot;</span>);<br></code></pre></td></tr></table></figure><p>摸索半天，解决把this去掉，应该是与关闭上下文隔离有关。</p><p>新问题：</p><p>不会出现其他问题了，也能正确require了，但是还是会有报错</p><p><code>Uncaught SyntaxError: Cannot use import statement outside a module (at main.js:6:1)</code></p><p>查看到不是自己的<code>main.js</code>而是要导入的<code>fullcalendar</code>的<code>main.js</code>，点进去看，错误行：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;./vdom.js&#x27;</span>;<br></code></pre></td></tr></table></figure><p>查询才发现Js还分CommonJs和Es（行……），最主要的语法层面的区别就是import和export的使用上。也不想再继续写JavaScript了，也就了解了下CommonJs使用require导入，Es使用import导入。Es也没有<code>__dirname</code>这个变量。</p><p>更详细的说明可见博文：<ahref="https://www.ruanyifeng.com/blog/2020/08/how-nodejs-use-es6-module.html">Node.js如何处理 ES6 模块 - 阮一峰的网络日志</a></p><p>简单说要导入的包可能用了Es语法格式的导入（在自己的代码中），所以和目前electron没有开启Es支持的CommonJs里不兼容。</p><p>尝试在<code>package.json</code>中打开<code>”type”: “module”</code>，按Es格式更改后还是不行，直接是electron层面的报错，谷歌一下是electron就是不支持Es和module，只能放弃，另寻支持的module。</p><p>同学换了一个使用<code>jQeury</code>的calendarmodule，一切正常但一直报错<code>Uncaught ReferenceError: jQuery is not defined</code>，但在Js里已经定义了</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">window</span>.<span class="hljs-property">$</span> = <span class="hljs-variable language_">window</span>.<span class="hljs-property">jQuery</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;jquery&#x27;</span>);<br></code></pre></td></tr></table></figure><p>寻找半天终于发现，是自己写的Js放在了导入module的Js之后。调整下顺序，解决。</p><p>折腾半天终于可以在electron里用一个第三方的日历库显示日历样式。</p>]]></content>
    
    
    
    <tags>
      
      <tag>debug</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
